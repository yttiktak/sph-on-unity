#pragma kernel Gravity

struct Particle
{
	float3 pos;
	float3 vel;
	float3 f;
	float3 color;
	float d;
	float p;
};

RWStructuredBuffer<Particle> cloud;
uint _npts; // set! gag. Not in dispatch params??


[numthreads(1024, 1, 1)]
void Gravity(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	float l;
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		l = length(d);
		a +=  normalize(d) / (l*l);
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		l = length(d);
		a +=  normalize(d) / (l*l);
	}
	cloud[id.x].f = a;
	cloud[id.x].vel += a * 0.001;
};

#pragma kernel DensityPressure

#define PI_FLOAT 3.1415926535898
#define  PARTICLE_RADIUS 0.5
#define  PARTICLE_RESTING_DENSITY 1
#define  PARTICLE_MASS 1
#define  SMOOTHING_LENGTH 0.5
#define  PARTICLE_STIFFNESS 2000
#define  PARTICLE_VISCOSITY 3000
/*** STARTED FROM CODE BY:
// https://github.com/multiprecision/sph_opengl/tree/master/shader
// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//#version 460
// much mdifications, changes pending to go into 3D and follow papers such as:
// Daniel J. Price
// Smoothed Particle Hydrodynamics and Magnetohydrodynamics
***/ 

[numthreads(1024, 1, 1)]
void DensityPressure(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	float r;
	float dsum = 0;
	for (uint j = 0; j < _npts; ++j) {
		d = (cloud[j].pos - p.pos);
		r = distance(cloud[j].pos.xyz,p.pos.xyz);
		if (r < SMOOTHING_LENGTH)
		{
			dsum += PARTICLE_MASS * 315.0 * pow(SMOOTHING_LENGTH * SMOOTHING_LENGTH - r * r, 3) / (64.0 * PI_FLOAT * pow(SMOOTHING_LENGTH, 9));
		}
	}
	cloud[id.x].d = dsum;
	cloud[id.x].p = max(PARTICLE_STIFFNESS * (dsum - PARTICLE_RESTING_DENSITY), 0.f);
};

#pragma kernel PressureForce

[numthreads(1024, 1, 1)]
void PressureForce(uint3 id : SV_DispatchThreadID)
{
	float3 d;
	float r;
	float3 p_f = 0;
	float3 v_f = 0;
	Particle p = cloud[id.x];
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		r = length(d);
		if (r<SMOOTHING_LENGTH)
		{
			p_f += PARTICLE_MASS * (cloud[id.x].p + cloud[j].p) / (2.0 - cloud[j].d)* 
			45.0 / (PI_FLOAT * pow(SMOOTHING_LENGTH,6))*pow(SMOOTHING_LENGTH - r, 2) * normalize(d);
			v_f += PARTICLE_MASS * (cloud[j].vel - cloud[id.x].vel)/cloud[j].d * 
			45.0 / (PI_FLOAT * pow(SMOOTHING_LENGTH,6)) * (SMOOTHING_LENGTH -r);
		}
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		r = length(d);
		if (r<SMOOTHING_LENGTH)
		{
			p_f += PARTICLE_MASS * (cloud[id.x].p + cloud[j].p) / (2.0 - cloud[j].d)* 
			45.0 / (PI_FLOAT * pow(SMOOTHING_LENGTH,6))*pow(SMOOTHING_LENGTH - r, 2) * normalize(d);
			v_f += PARTICLE_MASS * (cloud[j].vel - cloud[id.x].vel)/cloud[j].d * 
			45.0 / (PI_FLOAT * pow(SMOOTHING_LENGTH,6)) * (SMOOTHING_LENGTH -r);
		}
	}
	v_f *= PARTICLE_VISCOSITY;
    cloud[id.x].f = (p_f + v_f); // external force from gravity not in place yet
}

#pragma kernel CSMain

[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		a +=  d * length(d);
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		a +=  d * length(d);
	}
	cloud[id.x].vel += a * 0.00000001;
};