#pragma kernel Gravity
#pragma kernel DensityPressure
#pragma kernel PressureForce
#pragma kernel Integrate
#pragma kernel Power
#pragma kernel CSMain

struct Particle
{
	float3 pos;
	float3 vel;
	float3 force;
	float3 color;
	float d;
	float p;
};

RWStructuredBuffer<Particle> cloud;
uint _npts; // set! gag. Not in dispatch params??

// some globals
float particleRadius;
float particleRestDensity;
float particleMass;
float smoothingLength;
float smoothingLength3; // cubed
float smoothingLength6; // pow(sml,6)
float particleStiffness;
float particleViscosity;
float time_step; 

#define PI_FLOAT 3.14159265358979

[numthreads(1024, 1, 1)]
void Gravity(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	float l;
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		l = length(d);
		a +=  normalize(d) / (l*l);
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		l = length(d);
		a +=  normalize(d) / (l*l);
	}
	cloud[id.x].force = a;
	cloud[id.x].vel += a * 0.001;
};



/*** STARTED FROM CODE BY:
// https://github.com/multiprecision/sph_opengl/tree/master/shader
// also see:
// rlguy.com/sphfluidsim/
// 
// much mdifications, changes pending to go into 3D and follow papers such as:
// Daniel J. Price
// Smoothed Particle Hydrodynamics and Magnetohydrodynamics
***/ 

// Price, eq. # 6
float CubicSpline(float q) {
	float result;
	if (q < 1) {
		result = 0.25 * pow((2.0-q),3) - pow((1.0-q),3);
	} else {
	 	if (q<2) {
			result = 0.25 * pow((2.0-q),3);
		} else {
			result = 0;
		}
	}
	return result / ( smoothingLength3 * PI_FLOAT);
}

// Price, eq # 85
float GradCubicSpline(float q) {
	float result;
	if (q < 0.666) {
		result = 1; 
	} else {
	 	if (q<1) {
			result = -3.0*q + 2.25*pow(q,2);
		} else {
			result = 0.75 * pow((2.0 - q),2);
		}
		if (q > 2) {
		    result = 0;
		}
	}
	return result / ( PI_FLOAT);
}

[numthreads(1024, 1, 1)]
void DensityPressure(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	float r;
	float dsum = 0;
	for (uint j = 0; j < _npts; ++j) {
		d = (cloud[j].pos - p.pos);
		r = distance(cloud[j].pos.xyz,p.pos.xyz);
		if (r < smoothingLength)
		{
			dsum += particleMass * CubicSpline(r/particleRadius);
		}
	}
	cloud[id.x].d = dsum;
	cloud[id.x].p = max(particleStiffness * (dsum - particleRestDensity), 0.f);
};

[numthreads(1024, 1, 1)]
void PressureForce(uint3 id : SV_DispatchThreadID)
{
	float3 d;
	float r;
	float factor1;
	float3 p_fs = 0;
	float3 v_fs = 0;

	factor1 = 45.0 / (PI_FLOAT * smoothingLength6);
	Particle p = cloud[id.x];
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		r = length(d);
		if (r<smoothingLength)
		{
			p_fs += (p.p + cloud[j].p) / (2.0 - cloud[j].d) *  pow(smoothingLength - r, 2) * normalize(d);
			v_fs += (cloud[j].vel - p.vel)/cloud[j].d *  (smoothingLength -r);
		}
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		r = length(d);
		if (r<smoothingLength)
		{
			p_fs += (p.p + cloud[j].p) / (2.0 - cloud[j].d)* factor1 * pow(smoothingLength - r, 2) * normalize(d);
			v_fs += (cloud[j].vel - p.vel)/cloud[j].d * factor1 * (smoothingLength -r);
		}
	}
	v_fs *= particleViscosity;
    cloud[id.x].force = particleMass * factor1 * ( v_fs + p_fs); // external force from gravity not in place yet
}


[numthreads(1024, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
	float3 a = cloud[id.x].force / cloud[id.x].d;
	cloud[id.x].vel += a * time_step;
	cloud[id.x].pos += cloud[id.x].vel * time_step;
};


[numthreads(1024, 1, 1)]
void Power(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		a +=  d * length(d);
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		a +=  d * length(d);
	}
	cloud[id.x].force = a * 0.001;
};



[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	Particle p = cloud[id.x];
	float3 a = 0;
	float3 d = 0;
	for (uint j = 0; j < id.x; ++j) {
		d = (cloud[j].pos - p.pos);
		a +=  d * length(d);
	}
	for (uint k = id.x+1; k < _npts; ++k) {
		d = (cloud[k].pos - p.pos);
		a +=  d * length(d);
	}
	cloud[id.x].vel += a * 0.00000001;
};
